The CPU is connected to the system’s main memory through a memory bus or connection.
A bus is a system for transferring data between components inside a computer or between computers:
Some devices, like graphics and high performance I/O devices are connected to the system using a general I/O bus like a PCI.
Peripheral buses like SCSI, SATA, and USB are used to connect slower devices like disks, mice, and keyboards.

Instead of constantly polling the device, the OS can use an interrupt to:
Send a request
Put the calling process to sleep, and
Switch the context to another job.

When the I/O request is finished, it sends a hardware interrupt and makes the CPU go into the OS to a specific interrupt handler. This handler is OS code that will complete the request, wake up the process that’s waiting for I/O to finish, and lets it continue about its merry way.

Direct Memory Access (DMA) is our answer to this problem. A DMA engine is a system component that handles transfers between devices and main memory without relying so much on the CPU.

The OS tells the DMA engine where and how much data to copy and what device to send data to.
Now, the OS is finished with the transfer and can go on to other tasks.
The DMA engine raises an interrupt when it’s finished, letting the OS know that the transfer is done.

Device communication is generally done in two ways:
Having explicit I/O instructions that define how the OS delivers data to specific device registers.(직접명령)

Memory-mapped I/O is the second method of interacting with devices.

Explicit I/O - Contains instructions that describe how the OS delivers data to specific device registers.

Memory-mapped I/O - Device registers are accessible in the same way as if they were memory addresses.

Device Driver

Device interface functionalities are wrapped within this piece of software called a device driver.

a file system (or application) doesn’t care about disk class. It just sends read and write requests to the generic block layer, which routes them to the appropriate driver.

Certain programs can read and write blocks directly without needing the file abstraction. Most systems support low-level storage management applications using this interface.

harddisk drives부터
-byte blocks) making up the drive. Each one can be read or written to. It’s like an array of n
 sectors, with an address space ranging from 0
 to n−1.

Now that we have a model of the disk, we can analyze its performance. We can represent Disk Access Time as:
TI/O=Tseek+Trotation+Ttransfer
 
Disk Response Time is the average time a request spends waiting for an I/O operation. The average response time is the average response time across all requests.
The rate of I/O (  RI/O
 ), which is often used to compare drives, is computed from the formula below:
RI/O=SizeTransferTI/O

Storage virtualization is based on two main ideas: the file and the directory.
A file is a group of bytes that can be read or written. Each file has a low-level name in the form of an inode number, that users don’t see very often. The file system makes sure that the original file data is always kept on the disk.
In a directory, the user-readable name and the low-level name are listed in pairs.

A program can create a new file by using open() and passing it the O_CREAT flag. The code to the left creates aFile in the current working directory.
The open() call accepts several flags. here:
O_CREAT - creates the file
O_WRONLY - locks it,
O_TRUNC - truncates it to zero bytes, erasing any existing content
S_IRUSR|S_IWUSR - permissions are set to allow the owner to read and write to the file.

open() returns a file descriptor

The open file table shows us the structures of these files as well as the system’s currently open files.

The private descriptor array of each process is linked to a shared open file table entry that connects to the underlying file-system inode. The reference count for file table entries shared by two processes increases until both processes exit the file.
(각각의 프로세스에 있는 filedescriptor는 동일한 파일 참조시 동일한 openfile table을 참조한다)

We expect a file system to keep certain information, called metadata, about each file it stores. To see a file’s metadata, you can use the stat() or fstat() system functions.

A file’s metadata includes information like:
The file’s size in bytes,
Inode number,
Ownership information
When the file was viewed or modified.

struct stat {
dev_t st_dev;         // ID of device containing file
ino_t st_ino;         // inode number
mode_t st_mode;       // protection
nlink_t st_nlink;     // number of hard links
uid_t st_uid;         // user ID of owner
gid_t st_gid;         // group ID of owner
dev_t st_rdev;        // device ID (if special file)
off_t st_size;        // total size, in bytes
blksize_t st_blksize; // blocksize for filesystem I/O
blkcnt_t st_blocks;   // number of blocks allocated
time_t st_atime;      // time of last access
time_t st_mtime;      // time of last modification
time_t st_ctime;      // time of last status change
};
We can use the stat command-line tool to learn about a file.
stat filename으로 메타데이터 조회가능

Directory data is considered metadata, so you can only update a directory by creating files, directories, or other things within it. This is how the file system makes sure directory contents are correct.

The mkdir() call can create a directory from within an existing program. The mkdir program can create such a directory. The code below creates a basic directory called downloads with the mkdir program.

Instead of opening a directory as a file, the ls program uses three functions:
opendir()
readdir()
closedir()
We can see from the program to the left that ls is basically a loop that reads one directory entry at a time, printing out the name and inode number of each file in the directory.

struct dirent {
  char d_name[256];        // filename
  ino_t d_inode;             // inode number
  off_t d_offset;             // offset to the next dirent
  unsigned short d_recordlen; // length of this record
  unsigned char d_type;    // type of file
};(이정보가 directoriy에 보관됨)

link() creates a new name in the directory and refers it to the same inode number as the original file.

Making a file completes two tasks by
Creating an inode structure that will track the file’s metadata, and
Linking that file to a human-readable name to be put in a directory.

The original file name and the new file name are both links to the underlying metadata about the file stored in inode number

When the file system unlinks a file, it checks the inode number’s reference count or link count. The reference count keeps track of how many files have been linked to this inode.

A symbolic link, or soft link is similar to creating a hard link, but a bit different. A symbolic link is a different type of file. Just like regular files and directories, symbolic links are a third type of file that the system recognizes.

 File systems frequently have a broader set of techniques for varying levels of sharing.
The first type is the UNIX permission bits.
 
Permissions are divided into three categories:
what the file’s owner can do,
what a group can do, and
what anyone (known as other) can do.

A process has to first ask the operating system for permission to access a file. A file descriptor is returned if permission is given with the intent to enable read or write access.
Each file descriptor relates to an entry in the open file table. A file’s current offset and other important information are tracked in this entry.
Processes can use lseek() to modify the current offset, allowing random access to different regions of the file.
A process must use fsync() or similar functions to update persistent data. However, doing so correctly while keeping high performance is difficult.
You can use hard links or symbolic links to have several human-readable names point to the same underlying file. Consider their strengths and disadvantages before using them. Remember that removing a file only unlinks it from the directory hierarchy.
Most file systems allow you to turn sharing on and off. Permissions bits give a basic method for these controls. Access control lists provide more precise control over who can access and change data.