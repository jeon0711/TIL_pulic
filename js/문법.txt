프로토타입 기반 언어, 멀티패러다임 지원한다. 함수생성시 함수의 멤버로 그 함수의 프로토타입 객체를 참조하고(함수의 멤버로서
프로토타입속성이 프로토타입 객체를 참조), 그 프로토타입 객체의 생성자는 해당 함수를 참조. 이 함수로 생성되는 객체는 모드 이 프로토 타입 객체의 원형이며
이 프로토 타입을 참조한다. 따라서 이 프로토타입 객체에 속성,함수를 추가하면 모든 객체에서 실행가능.
생성된 객체에서 프로토타입 객체에 있는 속성을 수정하려면 프로토타입 객체에 접근한 뒤 수정해야한다. 아니면 해당 객체에서 오버라이딩된다.

기본 데이터타입을 제외한 모든 데이터가 객체이며, 이 객체들은 프로토타입 객체들로 만들어짐, 동일한 이름의 함수(생성자)도 늘 있고. 이 한쌍이 서로를 참조하는 형태로

객체 생성방법이 여럿
클래스,
object.create,
object 생성자함수
객체 리터럴(직접 대입,key:value를 직접입력),
생성자함수
생성 방식 자체가 다른듯.

:으로 키와 value 구분하고, tag로 쓸수도 있다,tag도
결국 key,value는 대상 함수,객체등.

객체는 연관배열로서 배열의 인덱스를 key로, 내부 속성(프로퍼티)나 메소드를 value로 가지는 map처럼 사용할수
있다. map의 경우 red-black tree,
결국 일정크기 이상의 데이터는 tree+hashtable꼴일
수밖에 없다.
중요한건 멤버 이름 자체도 대괄호 통해서 동적으로
설정가능하다는것. 변수에 string넣고 그 변수를
인덱스로 하면 그 변수의 value를 key로 하는 객체내부설정됨.

객체는 그 형태인 클래스, 그리고 형성되는게 인스턴스
class person...
person man;이면 person이 class,man이 인스턴스다

모든 객체들이 메소드와 속성들을 상속받기 위한 템플릿으로서 프로토타입 객체를 가지고, 객체의 생성자(함수)
의 prototype속성=각 객체 인스턴스의 proto속성=
프로토타입의 참조이다. 프로토타입의 생성자=
객체의 생성자이고, 함수의 객체인 경우에도 동일하다.
내부 속성,메소드 호출시
이 프로토타입 링크를 계속 거슬러 올라가면서 검색한다.
모든 객체는 object객체의 프로토타입부터 시작.
어떤 클래스를 정의하거나 함수를 정의하고, 인스턴스 생성하면, 그 객체의 프로토타입의 생성자는 동명의 함수를
참조하고, 해당 함수의 prototype속성은 동명의 클래스를참조하며, 객체의 프로토타입은 다시 상위 prototype
(__proto__속성등이)(object의 프로토타입)을 참조한다.

먼저 인스턴스의 메소드,프로퍼티 확인하고 해당 객체의
프로토타입(객체의 생성자의 프로토타입속성이 객체의 프로토타입 참조하며,,프로토타입 객체도 객체이기에 다른 프로토타입 객체의 생성자를 통해 만들어진다.(최소한 object의)그렇기에 해당 객체도 __proto__속성등에 상위프로토타입을 참조하고, 그렇기에 참조대상 바꾸려면 객체의 생성자의 프로토타입을 바꿔야)을 확인하고 다시 해당 

상속 관점에서 자바스크립트의 유일한 생성자는 객체뿐이다. 각각의 객체는 [[Prototype]]이라는 은닉(private) 속성을 가지는데 자신의 프로토타입이 되는 다른 객체를 가리킨다. 그 객체의 프로토타입 또한 프로토타입을 가지고 있고 이것이 반복되다, 결국 null을 프로토타입으로 가지는 오브젝트에서 끝난다. null은 더 이상의 프로토타입이 없다고 정의되며, 프로토타입 체인의 종점 역할을 한다.

함수는 전부 Function객체다.function객체도 object의 하위.
(function(){}).constructor===Function이 true
리턴.

정리하면
object 객체의 프로토타입이 존재하고, 이것의 생성자
매서드,즉 ()를 정의해놓은게 존재. object객체의 프로토타입

모든 생성자 함수는 Function의 인스턴스

정리하면 object의 프로토타입이 먼저 있다.
그리고 Function의 prototype이 이것의 인스턴스이고
Function 객체를 만들어 위의 prototype을 넣는다.
Function객체는 ()를 메서드로 가지고, Function 인스턴스를 리턴한다. 이제 Object의 객체를 만들고, 생성자 함수를 Function의 인스턴스로 넣는다. 

즉 오브젝트의 프로토타입을 만들고, 이걸 기반으로 함수객체의 프로토타입을 만들며, 이제 함수객체의 프로토타입을 포함하는 함수 객체를 만들고
(함수객체는 ()오버로딩한것처럼, 함수포인터등 넣고 해당 부분 호출되면 함수포인터에 인자넣고 실행되도록 하면됨. 함수포인터의 호출은 명령어의 제어구문의 실행명령이므로(해당 함수를 시작하는 부분의 명령어를 인스트럭터 레지스터, 즉 명령어 넣어두는 레지스터로 가져오는 명령어이다. 자세한건 컴구기초에 넣어둠 ), 오브젝트의 생성자 함수를 함수객체의 인스턴스로 만든다.

